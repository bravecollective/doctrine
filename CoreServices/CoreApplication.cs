namespace CoreServices
{
    using System;
    using System.Security.Cryptography;
    using System.Text;

    /// <summary>
    /// Represents a core application with its identifier and ECDSA keys. For use with core services.
    /// </summary>
    public class CoreApplication : ICoreApplication
    {
        private ECDsaCng localKey;
        private ECDsaCng serviceKey;

        /// <summary>
        /// The local private/public key pair for the application. The private key is used to sign requests to core.
        /// Core requires an exported copy of the public key from this pair to be able to validate the application requests.
        /// </summary>
        public ECDsaCng LocalKey
        {
            get
            {
                return this.localKey;
            }
        }

        /// <summary>
        /// The application-specific public key generated by the core service. This is used to validate core responses that have been
        /// signed with an application-specific private key on the server-side.
        /// </summary>
        public ECDsaCng ServiceKey
        {
            get
            {
                return this.serviceKey;
            }
        }

        /// <summary>
        /// The application identifier as provided by the core service.
        /// </summary>
        public string Id { get; set; }

        /// <summary>
        /// Generates a new local private/public key pair for the application.
        /// </summary>
        public CoreApplication()
        {
            // Set the key creation parameters, allowing export.
            CngKeyCreationParameters creationParams = new CngKeyCreationParameters();
            creationParams.ExportPolicy = CngExportPolicies.AllowExport;
            creationParams.KeyUsage = CngKeyUsages.Signing;

            // Create an application key using the P256 NIST curves.
            CngKey cngKey = CngKey.Create(CngAlgorithm.ECDsaP256, null, creationParams);

            // Instantiate and assign a new ECDSA instance and set the hashing algorithm to SHA256.
            localKey = new ECDsaCng(cngKey);
            this.localKey.HashAlgorithm = CngAlgorithm.Sha256;
        }

        /// <summary>
        /// Imports an existing serialised application configuration.
        /// </summary>
        /// <param name="serializedApp">A hex-encoded string containing the application id and keys.</param>
        public CoreApplication(string serializedApp)
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Serialize the application configuration to store it for later use.
        /// </summary>
        /// <returns>Returns a serialized string containing the application id and keys.</returns>
        public string Serialize()
        {
            throw new NotImplementedException();
        }

        /// <summary>
        /// Export the public portion of the local application key pair. This should be submitted to core for the application.
        /// </summary>
        /// <returns>Returns a hex-encoded string containing the local application public key.</returns>
        public string ExportPublicLocalKey()
        {
            return this.BytesToHex(this.localKey.Key.Export(CngKeyBlobFormat.EccPublicBlob));
        }

        /// <summary>
        /// Import the application-specific public key generated by the core service.
        /// </summary>
        /// <param name="hexServiceKey">The application-specific public key encoded as hex.</param>
        public void ImportPublicServiceKey(string hexServiceKey)
        {
            // Import the existing key, converting from hex to a byte array.
            CngKey cngKey = CngKey.Import(this.HexToBytes(hexServiceKey), CngKeyBlobFormat.EccPublicBlob);

            // Instantiate and assign a new ECDSA instance and set the hashing algorithm to SHA256.
            serviceKey = new ECDsaCng(cngKey);
            this.serviceKey.HashAlgorithm = CngAlgorithm.Sha256;
        }

        internal string BytesToHex(Byte[] inputBytes)
        {
            StringBuilder sbBytes = new StringBuilder(inputBytes.Length * 2);

            foreach (byte b in inputBytes)
            {
                sbBytes.AppendFormat("{0:X2}", b);
            }

            return sbBytes.ToString();
        }

        internal Byte[] HexToBytes(string inputString)
        {
            throw new NotImplementedException();
        }
    }
}
